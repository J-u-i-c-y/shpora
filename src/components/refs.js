import React from 'react';
import HeaderComp from './header';
import FooterComp from './footer';
import { Layout } from 'antd';

const { Content } = Layout;

const Refs = () => {
  return (
    <div className="App" >
      <Layout className="layout">
        <HeaderComp />
        <Content style={{ padding: '50px 50px 0' }}>
          <div className="site-layout-content">
            <h1 className="main-title">Рефы</h1>
            <p>Рефы дают возможность получить доступ к DOM-узлам или React-элементам, созданным в рендер-методе.</p>
            <p>В обычном потоке данных React родительские компоненты могут взаимодействовать с дочерними только через пропсы.
              Чтобы модифицировать потомка, вы должны заново отрендерить его с новыми пропсами.Тем не менее,
              могут возникать ситуации, когда вам требуется императивно изменить дочерний элемент,
              обойдя обычный поток данных.Подлежащий изменениям дочерний элемент может быть как React-компонентом,
              так и DOM-элементом.React предоставляет лазейку для обоих случаев.</p>
            <p className="subtitle">Когда использовать рефы</p>
            <p>Ситуации, в которых использование рефов является оправданным:</p>
            <ul>
              <li>Управление фокусом, выделение текста или воспроизведение медиа.</li>
              <li>Императивный вызов анимаций.</li>
              <li>Интеграция со сторонними DOM-библиотеками.</li>
            </ul>
            <p className="subtitle">Не злоупотребляйте рефами</p>
            <p>Возможно, с первого взгляда вам показалось, что рефы применяются, когда нужно решить какую-то задачу в вашем приложении «во что бы то ни стало».
              Если у вас сложилось такое впечатление, сделайте паузу и обдумайте, где должно храниться конкретное состояние в иерархии компонентов. Часто становится очевидно,
              что правильным местом для хранения состояния является верхний уровень в иерархии</p>
            <p className="subtitle">Создание рефов</p>
            <p>Рефы создаются с помощью <code>React.createRef()</code> и прикрепляются к React-элементам через <code>ref</code> атрибут. Обычно рефы присваиваются свойству экземпляра класса в конструкторе,
              чтобы на них можно было ссылаться из любой части компонента.</p>
            <div className="code-block">
              <pre><code>{`class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return <div ref={this.myRef} />;
  }
}`}
              </code></pre>
            </div>
            <p>Обратите внимание, что мы передаём props базовому (родительскому) конструктору: </p>
            <div className="code-block">
              <pre><code>{`constructor(props) {
  super(props);
  this.state = {date: new Date()};
}`}
              </code></pre>
            </div>
            <p className="subtitle">Доступ к рефам</p>
            <p>Когда реф передаётся элементу в методе <code>render</code>, ссылка на данный узел доступна через свойство рефа <code>current</code>.</p>
            <div className="code-block">
              <pre><code>{`const node = this.myRef.current;`}
              </code></pre>
            </div>
            <p>Значение рефа отличается в зависимости от типа узла:</p>
            <ul>
              <li>Когда атрибут <code>ref</code> используется с HTML-элементом, свойство <code>current</code> созданного рефа в конструкторе с помощью <code>React.createRef()</code> получает соответствующий DOM-элемент.</li>
              <li>Когда атрибут <code>ref</code> используется с классовым компонентом, свойство current объекта-рефа получает экземпляр смонтированного компонента.</li>
              <li><b>Нельзя использовать ref атрибут с функциональными компонентами</b>, потому что для них не создаётся экземпляров.</li>
            </ul>
          </div>
        </Content>
        <FooterComp />
      </Layout>
    </div>
  )
}

export default Refs;
